rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ================================================================
    // Helper functions
    // ================================================================
    function isSignedIn() {
      return request.auth != null;
    }

    function isVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }

    function isUbcEmail() {
      return isSignedIn()
        && (request.auth.token.email.matches('.*@student\\.ubc\\.ca$')
            || request.auth.token.email.matches('.*@ubc\\.ca$'));
    }

    // Global gate: verified + UBC email
    function isAuthorized() {
      return isVerified() && isUbcEmail();
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    // Check if viewer can read an event (for subcollection rules)
    function canReadEvent(eventId) {
      let event = get(/databases/$(database)/documents/connectEvents/$(eventId)).data;
      return event.visibility == 'public'
             || event.createdBy == request.auth.uid
             || (event.visibility == 'friends'
                 && exists(/databases/$(database)/documents/users/$(event.createdBy)/friends/$(request.auth.uid)));
    }

    // ================================================================
    // users/{uid} â€” User profiles
    // ================================================================
    match /users/{uid} {
      // Any authorized user can read any profile
      allow read: if isAuthorized();

      // Users can only create/update their own profile
      allow create: if isAuthorized()
                    && isOwner(uid)
                    && request.resource.data.keys().hasOnly([
                         'displayName', 'displayNameLower', 'photoURL', 'bio', 'program',
                         'year', 'interests', 'createdAt', 'lastActiveAt'
                       ])
                    && request.resource.data.displayName is string
                    && request.resource.data.displayName.size() >= 1
                    && request.resource.data.displayName.size() <= 50;

      allow update: if isAuthorized()
                    && isOwner(uid)
                    && request.resource.data.keys().hasOnly([
                         'displayName', 'displayNameLower', 'photoURL', 'bio', 'program',
                         'year', 'interests', 'createdAt', 'lastActiveAt'
                       ])
                    && request.resource.data.displayName is string
                    && request.resource.data.displayName.size() >= 1
                    && request.resource.data.displayName.size() <= 50
                    && (!('bio' in request.resource.data) || request.resource.data.bio.size() <= 280);

      allow delete: if false; // profiles are not deletable

      // ------ friends subcollection ------
      match /friends/{friendUid} {
        // Any authorized user can see anyone's friend list
        allow read: if isAuthorized();

        // A user can create a friend edge in ANY user's collection, AS LONG AS
        // they are one of the two parties in an ACCEPTED friendRequest.
        // This is necessary because when A accepts B's request, A must write to B's subcollection.
        allow create: if isAuthorized()
                      && request.resource.data.keys().hasOnly(['friendUid', 'since', 'createdAt'])
                      // If writing to uid=A, friendUid=B
                      // The current user must be A or B
                      && (request.auth.uid == uid || request.auth.uid == request.resource.data.friendUid)
                      // And there must be an accepted request between them
                      && (
                           (
                             existsAfter(/databases/$(database)/documents/friendRequests/$(uid + '_' + request.resource.data.friendUid))
                             && getAfter(/databases/$(database)/documents/friendRequests/$(uid + '_' + request.resource.data.friendUid)).data.status == 'accepted'
                           ) || (
                             existsAfter(/databases/$(database)/documents/friendRequests/$(request.resource.data.friendUid + '_' + uid))
                             && getAfter(/databases/$(database)/documents/friendRequests/$(request.resource.data.friendUid + '_' + uid)).data.status == 'accepted'
                           )
                         );

        // A user can only delete their own friend edge
        // Owner can delete their own edge, OR the friend can delete their edge from this user's list
        allow delete: if isOwner(uid)
                      || (isAuthorized() && friendUid == request.auth.uid);

        allow update: if false;
      }

      // ------ notifications subcollection ------
      match /notifications/{notificationId} {
        // Only recipient can read their own notifications
        allow read: if isAuthorized() && isOwner(uid);

        // Only recipient can update (mark read)
        allow update: if isAuthorized() && isOwner(uid)
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readAt']);

        // Create: actorUid must be the requester, targetUid must be the collection owner
        allow create: if isAuthorized()
                      && request.resource.data.actorUid == request.auth.uid
                      && request.resource.data.targetUid == uid
                      && request.resource.data.keys().hasOnly([
                           'type', 'actorUid', 'targetUid', 'eventId', 'commentId',
                           'rootCommentId', 'createdAt', 'readAt', 'actorName'
                         ])
                      && request.resource.data.type in ['friend_request', 'event_live', 'comment', 'reply'];

        allow delete: if false;
      }
    }

    // ================================================================
    // friendRequests/{fromUid}_{toUid}
    // ================================================================
    match /friendRequests/{requestId} {
      // Both sender and receiver can read their requests
      allow read: if isAuthorized()
                  && (request.auth.uid == resource.data.fromUid
                      || request.auth.uid == resource.data.toUid);

      // Create: only the sender, deterministic ID, status must be 'pending'
      allow create: if isAuthorized()
                    && request.resource.data.fromUid == request.auth.uid
                    && requestId == (request.resource.data.fromUid + '_' + request.resource.data.toUid)
                    && request.resource.data.status == 'pending'
                    && request.resource.data.keys().hasOnly([
                         'fromUid', 'toUid', 'status', 'createdAt', 'respondedAt'
                       ]);

      // Update: status transitions only using diff
      allow update: if isAuthorized()
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt', 'createdAt'])
                    && (
                         // toUid can accept or reject from pending
                         (request.auth.uid == resource.data.toUid
                          && resource.data.status == 'pending'
                          && request.resource.data.status in ['accepted', 'rejected'])
                         ||
                         // fromUid can cancel from pending
                         (request.auth.uid == resource.data.fromUid
                          && resource.data.status == 'pending'
                          && request.resource.data.status == 'cancelled')
                         ||
                         // fromUid can re-send if previously cancelled or rejected
                         (request.auth.uid == resource.data.fromUid
                          && resource.data.status in ['cancelled', 'rejected']
                          && request.resource.data.status == 'pending')
                       );

      allow delete: if false;
    }

    // ================================================================
    // connectEvents/{eventId}
    // ================================================================
    match /connectEvents/{eventId} {

      // Read: authorized user + visibility check
      allow read: if isAuthorized()
                  && (
                       resource.data.visibility == 'public'
                       || resource.data.createdBy == request.auth.uid
                       || (resource.data.visibility == 'friends'
                           && exists(/databases/$(database)/documents/users/$(resource.data.createdBy)/friends/$(request.auth.uid)))
                     );

      // Create: authorized, createdBy = uid, required fields, schema
      allow create: if isAuthorized()
                    && request.resource.data.createdBy == request.auth.uid
                    && request.resource.data.title is string
                    && request.resource.data.title.size() > 0
                    && request.resource.data.title.size() <= 80
                    && request.resource.data.description is string
                    && request.resource.data.description.size() > 0
                    && request.resource.data.description.size() <= 2000
                    && request.resource.data.visibility in ['public', 'friends']
                    && (!('locationName' in request.resource.data) || request.resource.data.locationName.size() <= 120);

      // Update: only creator, cannot change createdBy
      allow update: if isAuthorized()
                    && resource.data.createdBy == request.auth.uid
                    && request.resource.data.createdBy == request.auth.uid
                    && request.resource.data.title is string
                    && request.resource.data.title.size() > 0
                    && request.resource.data.title.size() <= 80
                    && request.resource.data.description is string
                    && request.resource.data.description.size() > 0;

      // Delete: only creator, must be authorized
      allow delete: if isAuthorized()
                    && resource.data.createdBy == request.auth.uid;

      // ------ comments subcollection ------
      match /comments/{commentId} {
        // Read: user must be able to read the parent event
        allow read: if isAuthorized() && canReadEvent(eventId);

        // Create: authorized, createdBy = uid, text 1-500 chars, threading fields allowed
        allow create: if isAuthorized()
                      && request.resource.data.createdBy == request.auth.uid
                      && request.resource.data.text is string
                      && request.resource.data.text.size() >= 1
                      && request.resource.data.text.size() <= 500
                      && request.resource.data.keys().hasOnly([
                           'text', 'createdAt', 'createdBy', 'createdByName',
                           'parentId', 'rootId', 'replyToUid'
                         ])
                      // Must be able to read parent event
                      && canReadEvent(eventId);

        allow update: if false;

        // Delete: only comment author
        allow delete: if isAuthorized()
                      && resource.data.createdBy == request.auth.uid;
      }

      // ------ rsvps subcollection ------
      match /rsvps/{rsvpUid} {
        // Read: same as parent event for normal queries
        allow read: if isAuthorized() && canReadEvent(eventId);

        // Write: authorized, doc ID must be uid, valid status
        // Create must have all fields. Update must only modify status/createdAt.
        allow create: if isAuthorized()
                      && rsvpUid == request.auth.uid
                      && request.resource.data.status in ['going', 'interested']
                      && request.resource.data.keys().hasOnly(['userId', 'status', 'createdAt', 'visibilitySnapshot'])
                      && request.resource.data.userId == request.auth.uid
                      && (!('visibilitySnapshot' in request.resource.data) || request.resource.data.visibilitySnapshot == get(/databases/$(database)/documents/connectEvents/$(eventId)).data.visibility);

        allow update: if isAuthorized()
                      && rsvpUid == request.auth.uid
                      && request.resource.data.status in ['going', 'interested']
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'createdAt']);

        allow delete: if isAuthorized() && rsvpUid == request.auth.uid;
      }
    }

    // ================================================================
    // Collection Group Queries
    // ================================================================
    match /{path=**}/rsvps/{rsvpUid} {
      // For fetchUserAttendingEventIds queries, which span multiple events.
      // We cannot realistically check `canReadEvent(eventId)` for a massive group query.
      // Instead, we ensure the query filters strictly on visibilitySnapshot == 'public' OR the user is querying their own RSVPs.
      allow read: if isAuthorized() && (
        request.auth.uid == rsvpUid || resource.data.visibilitySnapshot == 'public'
      );
    }

    // Default deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
